1. settimeout
2. Promise
3. 请求
4. addevent
5. 页面

浏览器内部有很多线程：
1. 定时器触发线程
2. http
3. GUI 线程

什么是 Event-loop (事件循环机制)
    浏览器协调用户交互， 渲染， 网络等任务

在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。


## 宏任务
- 渲染事件（如解析 DOM、计算布局、绘制）；
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
- JavaScript 脚本执行事件；(setTimeout)
- 网络请求完成、文件读写完成事件。

主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。(由宿主环境引起的任务)

## 微任务
基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术。Process.nextTick(node 端)

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。(由 js 本身引起的任务)
微任务可以在实时性和效率之间做一个有效的权衡。

## 流程
整体代码作为宏任务，进入主线程
只要宏任务队列不为空：

1. 从宏任务队列取出 **一个** 执行
2. 从微任务队列里面取出 **所有的** 执行，如果在这执行过程中又产生了微任务，再次重复第二步。
3. 有可能进入浏览器的重新渲染
    1. reqAnimationframe 回调
    2. 执行 IntersectionObserver 回调
    3. 重新绘制渲染

以 60fps 每一帧花费16.666 ms
我们的渲染是
一个宏任务 -> 清空微任务 -> 渲染 -> 一个宏任务 -> 清空微任务 -> 渲染 -> 一个宏任务 -> 清空微任务 -> 渲染
## 微任务的工作流程--结论
在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。


## MutationObserver
- 通过异步操作解决了同步操作的性能问题；
- 通过微任务解决了实时性的问题。